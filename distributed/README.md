# Amazon VPC Lattice - Multi-Account Distributed Service Networks

In this example, we are showing a multi-Account environment with [Amazon VPC Lattice](https://docs.aws.amazon.com/vpc-lattice/latest/ug/what-is-vpc-lattice.html), focusing on a distributed service network pattern. The service provider AWS Accounts will be the ones creating the VPC Lattice [services](https://docs.aws.amazon.com/vpc-lattice/latest/ug/services.html), while the consumer AWS Accounts will own their own service networks and associate the services they want to consume.

Why this specific pattern for a distributed model? Well, given there's a limit of 1:1 in terms of VPC association to a service network, makes sense that the consumer AWS Accounts are the ones owning and controlling the service networks, and then decide which services to consume - given the VPC service association to a service network is 1:many.

![Distributed diagram](../images/distributed.png)

An application can both consume services and be the target of another one. However, in this example we are supposing that the consumer and service provider are in different VPCs (and AWS Accounts), so we have 2 AWS Accounts involved in the architecture. Aside VPC Lattice resources, this example also deploys the following:

* [AWS Resource Access Manager](https://docs.aws.amazon.com/ram/latest/userguide/what-is.html) - to share the services between AWS Accounts
* [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/index.html) secrets - to share the service IDs between AWS Accounts.
  * [AWS KMS](https://docs.aws.amazon.com/kms/latest/developerguide/overview.html) key to encrypt the secrets.
* In the consumer AWS Account, Amazon VPCs, EC2 instances, and VPC endpoints (for [AWS Systems Manager session manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager.html) access) are deployed to test service consumption.
* In the service provider AWS Account, an [AWS Lambda](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html) function is deployed.

## Prerequities

* Two AWS Accounts - make sure you use different AWS credentials when initializing the provider in each folder.
* Terraform installed.

## Code Principles

* Writing DRY (Do No Repeat Yourself) code using a modular design pattern.

## Usage

* Clone the repository and move to the corresponding folder.

```
git clone https://github.com/aws-samples/multi-account-architectures-amazon-vpc-lattice.git
cd distributed
```

* Edit the *variables.tf* in each folder to configure your environments:
  * *consumer-account*: you need to provide the service AWS Account ID (the one creating the VPC Lattice services). In addition, you can configure the VPCs information (value provided by default).
  * *service-account*: you need to provide the consumer AWS Account ID.
* In all folders you can configure as well the AWS Region (value provided by default). Make sure you choose the same AWS Region for all the AWS Accounts, as all the resources created are regional.

## Deployment

Given we are working in a multi-Account environment, we need to deploy the resources in a specific order. The idea is also to show what is the normal deployment flow in a real environment when having centralized VPC Lattice resources - plus Secrets Manager secrets when sharing information between AWS Accounts.

**In each step, make sure you use the proper AWS Account (folder).**

### Step 1: Amazon VPC Lattice service (*service-account*)

The first thing to deploy are the VPC Lattice service, so we deploy all the resources in the service AWS Account - RAM share and Secrets Manager secret.

```
cd service-account
terraform apply
```

### Step 2: Amazon VPCs (consumer applications) and VPC Lattice resources - service network, service and VPC associations (*consumer-account*)

Last thing is the consumer VPCs so we can test the service consumption. We are deploying two VPCs - each one of them with EC2 instances and VPC endpoints for SSM access - to show the two different ways to create VPC Lattice VPC associations with different Terraform modules: [VPC module](https://registry.terraform.io/modules/aws-ia/vpc/aws/latest) and [VPC Lattice module](https://registry.terraform.io/modules/aws-ia/amazon-vpc-lattice-module/aws/latest). Per each VPC, a VPC Lattice service network is also deployed - and associated to it.

```
cd consumer-account
terraform apply
```

## Testing connectivity

Time to test that everything works properly! To connect to the VPC Lattice service created in the service Account, let's jump to the consumer AWS Account and connect to any of the EC2 instances created. As we deployed VPC endpoints to access AWS Systems Manager, you can connect to them using SSM Session Manager.

Once inside the EC2 instances, let's start doing DNS resolution of the VPC Lattice's domain name.

```
dig {domain_name}
```

Note that this domain name was generated by VPC Lattice, but you can also configure [custom domain names](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-custom-domain-name.html). DNS resolution will give us a link-local address (inside the 169.254.171.X range), basically telling us that to consume that service the traffic needs to be sent to the VPC Lattice association. If you configure a custom domain name, you will need to create an [Amazon Route 53 private hosted zone](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/hosted-zones-private.html) to map this custom domain name to the VPC Lattice generated one (CNAME record).

```
curl {domain_name}
```

You should receive something similar to *"Hello from Lambda!"*. You are now connecting applications in different VPCs in a multi-Account environment using Amazon VPC Lattice. The example provided is simple to avoid extra costs when deploying the environment, so take into account the following **best practices** when working with VPC Lattice:

* Use custom domain names and HTTPS listeners to make sure your traffic is encrypted. You will need to provide your [own certificate](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-byoc.html) (using [AWS Certificate Manager](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html)) when creating the VPC Lattice service.
* We provided an example on how to include an [auth policy](https://docs.aws.amazon.com/vpc-lattice/latest/ug/auth-policies.html) in both service network and service, but the IAM policy used is very open (allowing both authenticated and unauthenticated access). VPC Lattice works with [Signature Version 4 (SigV4)](https://docs.aws.amazon.com/vpc-lattice/latest/ug/sigv4-authenticated-requests.html) for client authentication. Our recommendation is use SigV4 and/or your own authentication method to make sure requests are only allowed from trusted consumers.

## Cleanup

Same as with the deployment, we need to destroy the resources in a certain order.

* First, remove all the resources in the consumer AWS Account (*consumer-account*)

```
cd consumer-account
terraform destroy
```

* Finally, remove all the resources in the service provider AWS Account (*service-account*)

```
cd service-account
terraform destroy
```